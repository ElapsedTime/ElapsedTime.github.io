<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解计算机系统笔记二</title>
      <link href="/2020/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2020/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>一,寻址与字节顺序</p><ol><li><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用的字节中最小的地址。例如，int变量x的地址为0x100（假设数据类型int为32位表示）x 的4个字节将被存储在内存0x00,0x01,0x02,0x03位置，地址取最小的位置。</p></li><li><p>某些机器选择在内存中 按照从最低有效字节到最高有效字节的顺序存储对象—-最低有效字节在最前面称为小端法。</p><p>小端法：      0x100                0x101                0x102                0x103            —</p><p>​                        01                        23                    45                        67</p><p>另一些机器则按照从最高有效字节到最低有效字节的顺序存储—–最高有效字节在前面的方式称为大端法。</p><p>大端法：     0x100                0x101                0x102                0x103            —</p><p>​                        67                    45                        23                        01</p><h6 id="32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址"><a href="#32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址" class="headerlink" title="32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址"></a>32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址</h6></li><li><p>布尔代数的运算。二进制1和0表示逻辑值TRUE或者FALSE，而运算符~，&amp;，|，^ 分别表示逻辑NOT(取反)，AND,OR,非（异或）</p></li><li><h3 id="切勿混用带符号类型和无符号类型"><a href="#切勿混用带符号类型和无符号类型" class="headerlink" title="切勿混用带符号类型和无符号类型"></a>切勿混用带符号类型和无符号类型</h3><p>如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成为无符号数。例如一个形如 a*b 的式子中，如果 a=-1,b=1，而且a，b都是int类型，则表达式的值显然为-1，然而如果a是int，而b是unsigned int，则结果须视在当前机器上int所占位数而定，在32位计算机系统中，结果是4294967295。</p></li><li><p>不同精度大数据量转换时需慎重</p></li></ol><p>二,预防蠕虫与病毒</p><ol><li>蠕虫：可以自己运行，并且能够将自己的等效副本传播到其他机器。病毒：能将自己添加到包括操作系统在内的其他程序中，不能独立运行。通过输入给程序一个字符串，包含一些可执行代码的字节编码，称为攻击代码(病毒)。</li><li>栈随机化：栈随机化的思想是使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，栈地址不同。防止被相同病毒一起破坏。实现方法是：程序开始时，在栈上分配一段0-n字节之间的随机大小的空间</li><li>栈破坏检测：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（cannary）值，也称哨兵值，是在程序每次运行时随机产生的，因此攻击者没有简单的方法知道他是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者函数调用的某个函数的某个操作改变了。如果是的，那么程序异常终止。</li><li>限制可执行代码区域：最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制只允许读和写。虚拟内存空间在逻辑上被分成了页，典型的每页是2048或者4096字节。</li></ol><p>三,优化程序性能</p><ol><li>减少过程调用</li><li>消除不必要的内存引用</li><li>提高并行性</li></ol><p>四,虚拟内存</p><ol><li><p>虚拟内存是计算机系统最重要的概念之一。它成功的原因是因为它是沉默地，自动工作的，不需要程序员干涉的。</p><ul><li>虚拟内存是核心的：虚拟内存遍及计算机系统所有层面</li><li>虚拟内存是强大的。虚拟内存给予应用程序强大的能力，可以创建和销毁内存片，将内存片映射到磁盘文件的某个部分，以及其他进程共享内存。</li><li>虚拟内存是危险的。每次程序引用一个变量，间接引用一个指针，动态分配程序时，它就会和虚拟内存发生交互。如果虚拟内存使用不当，应用将遇到复杂危险的与内存有关的错误。</li></ul></li><li><p>计算机系统的主存被组织成一个有M个连续的字节大小的单元组成的数组，第一个字节地址0，最后一个字节地址M-1。每个字节都有唯一的物理地址（PA）。</p></li><li><p>虚拟寻址：cpu通过生成一个虚拟地址（VA）来访问主存，虚拟地址通过地址翻译转换为物理地址。</p></li><li><p>地址空间：是一个非负数整数地址的有序集合。如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。</p></li><li><p>虚拟内存作为缓存的工具：概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。VM系统将虚拟内存分割称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2的p次方字节。类似地，物理内存被分割为物理页。</p></li><li><p>在任意时刻虚拟页的集合都分为三个不相交的子集：</p><ul><li>未分配的：VM（虚拟机）系统还未分配的页。未分配的块没有任何数据和它们相关联，因此也就不占任何磁盘空间。</li><li>缓存的：当前已缓存在物理内存中的已分配页。</li><li>未缓存的：未缓存在物理内存中的已分配页。</li></ul></li><li><p>访问虚拟内存比访问磁盘时间短。</p></li><li><ul><li><h6 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h6><p>​    通过把一部分暂时不用的内存信息放到硬盘上</p><p>​    局部性原理，程序运行时候只有部分<strong>必要的信息装入内存</strong></p><p>​    内存中暂时<strong>不需要的内容放到硬盘上</strong>，当需要的时候从新交换回来</p><p><strong>系统似乎提供了比实际内存大得多的容量，称之为虚拟内存</strong></p><p> （1）<strong>局部性</strong>分为时间局部性和空间局部性</p><p>​       <strong>时间局部性</strong>就是如果一块内存被访问的时候，很有可能在不远的将来还会被访问</p><p>   <strong>空间局部性</strong>就是如果一块内存被访问，那么周围的内存也很有可能被访问</p></li><li><h6 id="什么是内存抖动（颠簸）-虚拟内存工作集的大小超过了物理内存大小，程序性能极慢"><a href="#什么是内存抖动（颠簸）-虚拟内存工作集的大小超过了物理内存大小，程序性能极慢" class="headerlink" title="什么是内存抖动（颠簸）:虚拟内存工作集的大小超过了物理内存大小，程序性能极慢"></a>什么是内存抖动（颠簸）:虚拟内存工作集的大小超过了物理内存大小，程序性能极慢</h6><p>本质是频繁的页调度行为</p><p>频繁的页调度，进程不断产生缺页中断</p><p>置换一个页，又不断再次需要这个页</p><p><strong>运行程序太多；页面替换策略不好。通过杀掉一些无关的进程(终止进程)或者增加物理内存解决</strong></p></li></ul></li><li><p>输入/输出（I/O）是在主存和外部设备（例如磁盘驱动器，终端和网络之间）之间复制数据的过程。</p><p>输入操作是从I/O设备复制数据到主存，而输出操作是从主存复制数据到I/O设备。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统笔记一</title>
      <link href="/2020/09/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2020/09/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h5 id="一，移位运算"><a href="#一，移位运算" class="headerlink" title="一，移位运算"></a>一，移位运算</h5><ol><li>1&lt;&lt;2+3&lt;&lt;4 =1&lt;&lt;2 + 3&lt;&lt;4 =1乘2的平方+3乘2的4次方=4+3*16=52</li></ol><h5 id="二，原码反码补码"><a href="#二，原码反码补码" class="headerlink" title="二，原码反码补码"></a>二，原码反码补码</h5><ol><li><p>原码：为二进制的数，如：10   原码0000 1010</p><p>反码：正数与原码相同，如：10   反码0000 1010</p><p>负数为原码0变1，1变0，（符号位不变）如：</p><p>-10 原码1000 1010</p><p>​       反码1111 0101</p><p>补码：正数的补码与原码相同，如：</p><p>10   补码0000 1010</p><p>负数的补码为反码加1，如：-10   </p><p>反码：1111 0101   </p><p>补码：1111 0110</p></li><li><p>计算机中存储的都是补码，因为计算机中只有加法机，所以所有减法运算，都必须用加法进行。</p></li><li><p>用补数代替原数，可把减法转变为加法。出现的进位就是模，此时的进位，就应该忽略不计。</p></li><li><p>二进制下，有多少位数参加运算，模就是在 1 的后面加上多少个 0。</p></li><li><p>补码就是按照这个要求来定义的：正数不变，负数即用模减去绝对值。</p></li><li><p>计算机减法运算时因为-0和0希望只出现一个且满足正数负数相加等于0，所以存储的都是补码</p><p>举例，3和（-3）相加，0011 + 1101 =10000，丢掉最高位，就是0000（0）</p><p>4和（-3）相加，0100 + 1101 =0001</p></li><li><p>参考<a href="https://blog.csdn.net/zl1zl2zl3/article/details/53327216">https://blog.csdn.net/zl1zl2zl3/article/details/53327216</a></p></li></ol><h5 id="三-AmdahL定律"><a href="#三-AmdahL定律" class="headerlink" title="三.AmdahL定律"></a>三.AmdahL定律</h5><ol><li><p>Gene Amdahl 计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察称为Amdahl定律。主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行应用程序需要时间为T(old).假设系统某部分所需执行时间与该时间的比例为a，而该部分性能提升比例为k。即该部分初始所需时间为aT(old),现在所需时间为aT(old)/K.因此总的执行时间应为：T(new)=(1-a)T(old)+(aT(old))/k=T(old)[(1-a)+a/k]</p><h6 id="由此，加速比S-T-old-T-new-为-S-1-1-a-a-k"><a href="#由此，加速比S-T-old-T-new-为-S-1-1-a-a-k" class="headerlink" title="由此，加速比S=T(old)/T(new) 为 S=1/((1-a)+a/k)"></a><u>由此，加速比S=T(old)/T(new) 为 S=1/((1-a)+a/k)</u></h6><p>举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为60%(a=0.6),其加速比例因子为3（k=3）。则我们可以获得的加速比为1/[0.4+0.6/3]=1.67倍。虽然我们对系统一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分加速比。这就是</p><p>Amdahl定律的主要观点—要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p></li></ol><h5 id="四-信息存储"><a href="#四-信息存储" class="headerlink" title="四.信息存储"></a>四.信息存储</h5><ol><li><p>大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中的位(bit)比特。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存每个字节都由唯一的数字来标识，称为他的地址，所有可能地址的集合就称为虚拟地址空间。</p></li><li><p>16进制数字对应关系：    0         1        2        3        4           5        6        7        8        9         A          B          C          D          E         F</p><p>10进制数字对应关系：    0         1        2        3        4           5        6        7        8        9        10        11        12        13        14        15        </p><p>二进制数字对应关系：0000   0001   0010  0011  0100  0101 0110   0111  1000  1001  1010  1011    1100    1101     1110   1111</p><p>在c语言中0x被默认为16进制数字</p><p>16进制和10进制转化：314156=19634*16+12          (C)</p><p>​                                       19634=1227*16+2               (2)</p><p>​                                          1227=76*16+11                (B)</p><p>​                                              76=4*16+12                  (C)</p><p>​                                                4=0*16+4                     (4)</p><p>314156的16进制为：0x4CB2C   </p><p>0x4CB2C  的10进制为：4×16的4次方+12×16的3次方+11×16的平方+2×16+12=314156</p></li><li><p>字数据大小：每台计算机都有一个字长（word size） ，指明指针数据的标称大小。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对一个字长为w位的机器而言，虚拟地址的范围为0-2w次方-1，程序最多访问2w次方个字节。最近出现了大规模从32位字长机器到64位的迁移。32位字长限制虚拟地址空间为4千兆字节（写作4GB），也就是说刚刚超过4×10的9次方字节。扩展到64位字长使得虚拟地址为16EB，大约1.84×10的19次方字节。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记一 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统</title>
      <link href="/2020/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一-系统硬件组成"><a href="#一-系统硬件组成" class="headerlink" title="一.系统硬件组成"></a>一.系统硬件组成</h1><ol><li><p>总线</p><p>贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字节中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4字节（32位），要么是8字节（64位）。</p></li><li><p>I/O 设备</p><p>I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个IO设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序hello就存放在磁盘上。</p><p>每个I/O设备都通过1个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统 的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，他们的功能都是在I/O总线和I/O设备之间传递信息。</p></li><li><p>主存</p><p>主存是一个临时存储设备，在处理执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性字节数组，每个字节有唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与c程序变量相对应的数据项大小是根据类型变化的。比如，运行linux的x86-64机器上，short类型的数据需要两个字节，int和float 类型需要4个字节，而long和double 类型需要8个字节。</p></li><li><p>处理器</p><p>中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，pc都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其执行下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作然后更新pc，使其指向下一条命令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</p><p>​    这样的简单操作并不多，他们围绕着主存，寄存器文件和算术/逻辑单元(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是cpu可能的执行操作。</p><ul><li>加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（pc）中，以覆盖pc中原来的值。</li></ul></li></ol><h1 id="二-程序执行"><a href="#二-程序执行" class="headerlink" title="二.程序执行"></a>二.程序执行</h1><ol><li>运行hello程序：当我们在键盘上输入字符串‘./hello’ 后，shell程序将字符逐一读入寄存器，再把它放到内存中。当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器存取DMA技术，数据可以不通过处理器直接从磁盘到达主存。一旦目标hello中的代码数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。</li><li>系统花费了大量的时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初是存放在磁盘上，当程序加载时，他们被复制到主存，当处理器运行程序时，指令又从主存复制到处理器。这些复制就是开销，减慢了程序真正的工作。因此，系统设计者的主要目标就是使这些复制操作尽可能快的完成。</li><li>根据机械原理，较大的存储设备要比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备。</li><li>进程：从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当读写文件时，他就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，他是系统管理全部进程所用代码和数据结构的集合。</li><li>线程：一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。因为多线程之间比多进程之间更容易共享数据，也因为线程一般比进程更高效，多处理器的时候 多线程并发更快。</li><li>虚拟内存：虚拟内存是一个抽象的概念，他为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。构成：<ul><li>程序代码和数据。对所有进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello</li><li>堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用标准库函数时，堆可以在运动时动态的扩展和伸缩。</li><li>栈。位于用户虚拟地址空间顶部的就是用户栈。</li><li>内核虚拟内存。地址空间顶部为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义函数。相反他们必须调用内核来执行这些操作。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概要:计算机系统漫游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇</title>
      <link href="/2020/09/09/%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/2020/09/09/%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一-编码"><a href="#一-编码" class="headerlink" title="一.编码"></a>一.编码</h1><p>1.人最伟大的进化就是语言和文字，前者方便我们交流，后者使我们的知识得以保留。但不是什么时候语言都是那么的方便，在离得很远的黑暗中，声音的传播会受到很多干扰。但光不会受到太多干扰反而更加便于观测，但是如何使光成为语言是个问题。</p><p>2.经过漫长的发展人们发现可以通过灯光的闪烁以及一定的间隔来发送信息，例如sos 可以用手电打出三短 三长 三短 来表示，通过这种方式与对照表可以进行加密通讯。而不会被其他人识别，是保密的好方法。但是缺失对照表会让人很头疼，而且很长的句子效率很低。</p><p>3.上述就是摩斯密码，后来用于电报和发送秘密信息。</p><p>4.在漫长的发展中，盲人布莱叶 发明了布莱叶编码，这是一种由空格和凸起形成的文字编码。短语“ you and me”在布莱叶编码中看起来是这样的：  <img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909151604890.png" alt="image-20200909151604890"></p><p>注意，代表同一个单词中的字母的小格用一个小距离分隔，大一些的距离（一般是没有<br>凸点的小格）用来分隔不同的单词。  这为机器编译文字提供了可能。</p><h1 id="二-电"><a href="#二-电" class="headerlink" title="二.电"></a>二.电</h1><p>1.一个原子的电子数通常等于其质子数。但在某种特定环境下，电子能从原子中电离出来，<br>这样电就产生了。  </p><p>2.手电筒电路中的电能显然比电火花或闪电之中的电能要好利用得多。灯泡能稳定持续地<br>亮是因为电子并不是从一点跳到另一点。当电路中的一个原子把一个电子传给邻接的另一个<br>原子时，它又从另一个邻接的原子获得电子，而这个原子又从它的一个邻接原子获得电子，<br>如此依次循环。可见电路中的电就是从原子到原子的电子通路。  </p><p>3.当电报机的键按下时，发生器的电磁铁将可动棒拖下发出“滴”的声音；当键放开时，<br>棒弹回初始位置，发出“嗒”的声音。快速的“嘀嗒”为点，慢速的则为划。字母 V代替接地的电池    </p><p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909172650513.png" alt="image-20200909172650513" style="zoom: 50%;" /><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909172752152.png" alt="image-20200909172752152"></p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909172818212.png" alt="image-20200909172818212" style="zoom:50%;" /><p>4.我们已经发明的这个装置叫重发器或<strong>继电器</strong>。一个继电器就像一个发声装置，输入的电流形成电磁用<br>以拖动金属杆，金属杆作为开关的一个部分连接到外接的导线上。这样，微弱的输入电流被<br>扩大形成比较强的输出电流。  </p><h1 id="三-数字进制"><a href="#三-数字进制" class="headerlink" title="三.数字进制"></a>三.数字进制</h1><p>​    1.因为人的手指是10个所以最早开始的是十进制。计算机普遍使用的是二进制。</p><p>​    2.下面是二进制的前1 6个数以及和它们等值的十进制数：  </p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909174206671.png" alt="image-20200909174206671" style="zoom:50%;" /><p>在数二进制数的时候，最右边的数字（也称最低位<br>数字）是在 0和1之间变化的。当它每次从 1变到0时，右数第二位数字（也称次低位数字）也<br>要发生变化，或者从 0变到1，或者从 1变到0。每次只要有一个二进制数位的值由 1变到0，紧<br>挨着的高位数字也会发生变化，要么从 0变到1，要么从1变到0。  </p><p>每次十进制加一，在二进制上也要加一，但是二进制最大是一所以当十进制为2时，二进制要进一，类似九进一。所以二进制的2 为0010.</p><p>3.通过将数字系统减少至只有 0和1两个数字的二进制数字系统，我们已经在能够接受的范<br>围内做了深入的讨论。不可能找到比二进制数字系统更简单的数字系统了。二进制数字系统<br>架起了算术与电之间的桥梁。前面各章中，我们所看到的开关、电线、灯泡、继电器等物体<br>都可以表示二进制数 0和1</p><p>4.二进制数与计算机密切相关！<br>大约在1 9 4 8年，美国数学家John Wilder Tukey （生于1 9 1 5年）提前认识到二进制数将在<br>未来几年中随着计算机的流行而发挥更大的作用。他决定创造一个新的、更短的词来代替使<br>用起来很不灵活的五音节词—binary digit。他曾经考虑用 b i g i t或b i n i t，但最后还是选用了短<br>小、简单、精巧且非常可爱的单词 b i t (比特)来代替binary digit这个词。  bit最小的数据单位。</p><p>5.数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。<br>还可以从以下几个方面来理解：<br>(1).字节(Byte)是电脑中表示信息含义的最小单位，因为在通常情况下一个ACSII码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八个位。人们之所以把字节称为电脑中表示信息含义的最小单位，表示最基本的字符，是因为一个位并不能表示我们现实生活中的一个相对完整的信息。另外，内存中运算的最小存储单位是字节，位运算也是在一个字节的存储单位的基础上进行的，所以存储的最小单位可以理解为字节。</p><p>(2).bit是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量称为一比特，是表示信息的最小单位，只有两种状态：0和1。电脑内部的电路工作有高电平和低电平两种状态.所以就用二进制来表示信号，以便计算机识别。所以计算机能传输的最小单位当然是你信号的单位bit，而不是字节，串口最小也有一位传递的。另外数字信息流的基本单位是bit（比特），时间的基本单位是s（秒），因此bit/s（比特/秒）是描述带宽的单位，1bit/s是带宽的基本单位，所谓的带宽其实指的是传输速度的快慢，也就是指在一个固定的时间内（1秒），能通过的最大位数据。</p><h1 id="四-逻辑"><a href="#四-逻辑" class="headerlink" title="四.逻辑"></a>四.逻辑</h1><p>​    1.传统代数的另外一个特点是它总是处理数字，如豆腐的重量或鸭子的数量，火车行驶的<br>​        距离或家庭成员的年龄。是布尔超凡的智慧使代数脱离了数字的概念而变得更加抽象。在布<br>​        尔代数中（布尔的代数最终被这样命名）操作数不是指数字，而是指集（类） 。一个类仅仅表<br>​        示一组事物，也就是后来熟知的集合。</p><ol start="2"><li><p>事实上，在布尔代数中我们并不真正地做加或乘，相反，这两个符号有着完全不同的意思。<br>在布尔代数中，符号 +意味着两个集合合并，两个集合的合并就是包含第一个集合的所有<br>成员及第二个集合的所有成员。例如， B + W表示黑猫和白猫的集合。<br>布尔代数中的符号×意味着取两个集合的交集，两个集合的交集包含的元素既在第一个<br>集合中，也在第二个集合中 。</p></li><li><p>交换律、结合律和分配律在布尔代数中均适用。而且，在布尔代数中，操作符 +可以对×<br>进行分配，这在传统代数中是不成立的，即：<br>W +（ B× F） =（ W + B）×（ W + F）<br>这个式子表示白猫（ W）和黑色母猫（ B× F）的并集和等式右边两个集合的交集是一样<br>的，这两个集合是白猫和黑猫的并集（ W + B）及白猫和母猫的并集（ W + F） 。要掌握这个规<br>则有些困难，但它的确有用。为了使布尔代数更加完整，我们还需要两个符号。这两个符号看上去像数字，但它们并<br>不真的是数字，因为有时候它们和数字有些不同。符号“ 1”在布尔代数中表示“整个宇宙<br>(全集)”，也就是我们所谈论的每件事物。本例中，符号“ 1”表示“所有的猫”。这样：<br>M + F = 1<br>即母猫和公猫的并集是所有的猫。同样，黄褐色猫、黑猫、白猫及其他颜色的猫的并集<br>也是所有的猫，即：    T + B + W + O = 1  </p><p>我们所需要的另外一个符号是“ 0”。在布尔代数中， “ 0”表示空集，即不含任何事物的<br>集合。当求取两个完全相互排斥的集合的交集时，空集就产生了。例如，既是母的又是公的<br>猫的集合可以表示为：<br>F× M = 0  </p></li><li><p>程序的执行借鉴了逻辑，使用了与（and|&amp;&amp;），或（or| ||），非（！求反），0代表没有 1代表存在。程序通过复杂的逻辑判断最终等到我们想要的结果。优先级 ! &gt; &amp;&amp; &gt; || </p></li></ol><h1 id="五-二进制加减法"><a href="#五-二进制加减法" class="headerlink" title="五.二进制加减法"></a>五.二进制加减法</h1><p>1.加法正是计算机唯一所做的事情  </p><p>2.原来的减法题目是：2 5 3－ 1 7 6<br>    表达式加一个数再减同一个数得到的结果是一样的。所以先加上 1 0 0 0，再减去1 0 0 0：<br>    2 5 3－ 176 + 1000－ 1 0 0 0<br>    这个式子等同于下面的式子：<br>    2 5 3－ 176 + 999 + 1－ 1 0 0 0<br>    再按如下方式重新组合：<br>    2 5 3 +（ 9 9 9 - 1 7 6） + 1－ 1 0 0 0<br>    这与前面描述过的用 9的补数进行的计算是一致的  </p><p>3.</p><p>同样的方法可用于二进制数减法，而且会比十进制数减法来得简单。让我们看看该如何做。<br>原来的减法题目是：<br>    2 5 3<br>－ 1 7 6<br>? ? ?<br>当把这些数转化为二进制数时，问题变成：<br>    １１１１１１０１<br>－１０１１００００<br>？？？？？？？？<br>步骤1 用11111111减去减数：<br>     1 1 1 1 1 1 0 1<br>－ 1 0 1 1 0 0 0 0<br>     0 1 0 0 1 1 1 1<br>当计算十进制数减法时，减数是从一串 9中减去，得到称为 9的补数的结果。对于二进制<br>数减法，减数从一串1中减去，差称为1的补数。但请注意，求1的补数实际上并不需要做减法，<br>因为1的补数中，原来的 0变成1，原来的 1变成0，所以， 1的补数有时也称为相反数 或反码。<br>（你是否还记得第11章中反向器的作用是把 0变成1，把1变成0。 ）<br>步骤2 把步骤1中求得的补数和被减数相加：<br>    1 1 1 1 1 1 0 1<br>+  0 1 0 0 1 1 1 1<br>1 0 1 0 0 1 1 0 0<br>步骤3 对结果加1：<br>1 0 1 0 0 1 1 0 0<br>+ 1<br>1 0 1 0 0 1 1 0 1<br>步骤4 减去1 0 0 0 0 0 0 0 0（ 2 5 6） ：  </p><p>​     1 0 1 0 0 1 1 0 1<br>－ 1 0 0 0 0 0 0 0 0<br>​           1 0 0 1 1 0 1<br>该结果就是十进制数 7 7。  </p><p>现在把两数颠倒位置后再做一遍。在十进制中，减法题目对应于：<br>1 7 6<br>－ 2 5 3<br>? ? ?<br>而在二进制中，即是：<br>    1 0 1 1 0 0 0 0<br>－ 1 1 1 1 1 1 0 1<br>? ? ? ? ? ? ? ?<br>步骤1 从11111111中减去减数。得到补数：<br>     1 1 1 1 1 1 1 1<br>－ 1 1 1 1 1 1 0 1<br>     0 0 0 0 0 0 1 0<br>步骤2 把步骤1中的补数和被减数相加：<br>   1 0 1 1 0 0 0 0<br>+ 0 0 0 0 0 0 1 0<br>   1 0 1 1 0 0 1 0<br>现在， 11111111必须再从结果中减掉。当减数比被减数小时，可以通过先加 1再减去<br>1 0 0 0 0 0 0 0 0来达到此目的。但现在这样做却会用到借位。所以，我们先用 11111111减去步骤2<br>中的结果：<br>1 1 1 1 1 1 1 1<br>－ 1 0 1 1 0 0 1 0<br>0 1 0 0 1 1 0 1<br>这实际上是对步骤2中得到的结果取反。最后的结果是 7 7，而真正的答案应该是－ 7 7。<br>现在，已经可以改进加法机使它既能执行加法操作亦能执行减法操作。为使简便起见，<br>这个加/减法机只执行被减数大于减数的减法操作，即差为正数的操作。  </p><h1 id="六-存储计算"><a href="#六-存储计算" class="headerlink" title="六.存储计算"></a>六.存储计算</h1><ol><li>例如，假设我们希望先把三个数字加在一起，然后把另两个数字加在一起，最后再把另<br>外三个数加在一起。我们可能会将这些数字存储在从地址 0 0 0 0 h开始的R A M阵列中，存储器<br>的内容如下所示：  <img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172514487.png" alt="image-20200910172514487" style="zoom:50%;" /></li></ol><p>这是本书第 1 6章所说明的内容。方格里是存储单元中的内容，存储器的每一个字节在一<br>个方格中。方格的地址在方格左面，并非每一个地址都要表示出来，存储器的地址是连续的，<br>因而可以算出某个方格的地址。方格的右侧是关于这个存储单元的注释，它们表示出我们希<br>望自动加法器在这些空格中存储三个结果。 （虽然这些方格是空的，但存储单元并非空的。存<br>储单元中总有一些东西，即使只是随机数，但此时它不是有用的数。 ）<br>现在可以试一下十六进制算术运算并且把结果存到方格中，但这并不是此项试验的要点，<br>我们想让自动加法器来做一些额外的工作。<br>不是让自动加法器只做一件事情—在最初的加法器中，只是把 R A M地址中的内容加到<br>称为累加器的 8位锁存器中—实际上是让它做四件不同的事。要做加法，需先从存储器中传<br>送一个字节到累加器中，这个操作叫作 L o a d（装载） 。第二项所要执行的操作是把存储器中的<br>一个字节加( A d d )到累加器中。第三项是从累加器中取出结果，保存 ( S t o r e )到存储器中。最后，<br>需要有一些方法使自动加法器停止 ( H a l t )工作。<br>详细说来，让自动加法器所做的工作如下所示：<br>• 把地址0 0 0 0 h中的数装载到累加器中<br>• 把地址0 0 0 1 h中的数加到累加器中<br>• 把地址0 0 0 2 h中的数加到累加器中<br>• 把累加器中的数保存到地址 0 0 0 3 h中<br>• 把地址0 0 0 4 h中的数装载到累加器中  </p><p>• 把地址0 0 0 5 h中的数加到累加器中<br>• 把累加器中的数保存到地址 0 0 0 6 h中<br>• 把地址0 0 0 7 h中的数装载到累加器中<br>• 把地址0 0 0 8 h中的数加到累加器中<br>• 把地址0 0 0 9 h中的数加到累加器中<br>• 把累加器中的数保存到地址 0 0 0 A h中<br>• 停止自动加法器的工作<br>注意，同最初的自动加法器一样，存储器的每个字节的地址是连续的，开始处为 0 0 0 0 h。<br>以前自动加法器只是简单地把存储器中相应地址的数加到累加器中。某些情况下，现在仍然<br>需要这样做，但有时我们也想直接把存储器中的数装载到累加器中或者把累加器中的数保存<br>到存储器中。在所有事情都完成以后，我们还想让自动加法器停下来以便检查 R A M阵列中的<br>内容。<br>怎样完成这些工作呢？只是简单地键入一组数到 R A M中并期望自动加法器来正确操作是<br>不可能的。对于 R A M中的每个数字，我们还需要一个数字代码来表示自动加法器所要做的工<br>作：装载，加，保存或停止。<br>也许最容易（但肯定不是最便宜）的方法是把这些代码存储在一个完全独立的 R A M阵列<br>中。这第二个 RAM 阵列与最初的 R A M阵列同时被访问，但它存放的不是要加的数，而是用<br>来表明自动加法器将要对最初的 R A M阵列的相应地址进行某种操作的代码。这两个 R A M阵列<br>可以分别标为数据（最初的 R A M阵列）和代码（新的 R A M阵列） ：  </p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172641916.png" alt="image-20200910172641916" style="zoom:50%;" /><p>已经确认新的自动加法器能够把“和”写入到最初的 R A M阵列（标为数据） ，而要写入新<br>的R A M阵列（标为代码）则只能通过控制面板来进行。<br>我们用4个代码来表示自动加法器希望能实现的 4个操作。 4个代码可任意指定，下面为可<br>能的一组代码：  </p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172724261.png" alt="image-20200910172724261" style="zoom:50%;" /><p>为了执行以上例子中提到的三组加法，需要用控制面板把下面这些数保存到代码R A M阵列中  :</p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172803127.png" alt="image-20200910172803127" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 原理:计算机发展史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐藏在计算机里的原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇</title>
      <link href="/2020/08/11/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2020/08/11/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一-学习计划"><a href="#一-学习计划" class="headerlink" title="一.学习计划"></a>一.学习计划</h1><p>1.数据结构与算法<br>2.计算机基础</p>]]></content>
      
      
      <categories>
          
          <category> 开始 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
