<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流逝时光</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-24T09:04:20.635Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>流逝时光</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python基础教程笔记一</title>
    <link href="http://yoursite.com/2020/09/23/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/09/23/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2020-09-23T06:44:28.000Z</published>
    <updated>2020-09-24T09:04:20.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一。基础知识"><a href="#一。基础知识" class="headerlink" title="一。基础知识"></a>一。基础知识</h1><ol><li>2+2=4 ,1/2=0.5 1/1=1.0 python / 除法保留小数点后一位，即浮点数。 如果想丢弃小数部分，即执行整除运算，可使用双斜杠：1//2=0  1//1=1</li><li>1%2=1 这是求余（求模）运算符。x%y的结果为x除以y的余数。即x%y 等价 于x-((x//y)*y) .10%3=1 10%-3=-2 -10%3=-2  10%-3=-1 10%2=0 。10//-3=-4 -10//3=-4 。造成这种原因是python//有向下取整的逻辑 正数3.33 向下取整为3  负数-3.33 向下取整 -4</li><li>2**3=8  -3**2=-9  (-3)**2=9 乘方（求幂）运算符</li><li>round(3.9)=4 round取整到最接近的整数 math.fllor(3.9)=3</li></ol><h1 id="二。列表和元组"><a href="#二。列表和元组" class="headerlink" title="二。列表和元组"></a>二。列表和元组</h1><ol><li><p>数据结构是以某种方式组合起来的数据元素集合。在python中，最基本的数据结构是序列。序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引为1，以此类推。可以用负索引表示序列末尾元素的位置。</p></li><li><p>列表和元组的主要不同在于，列表是可以修改的，而元组不可以。Hello[1]=e  Hello[-1]=o</p></li><li><p>除使用索引来访问单个元素外，还可以使用切片来访问特定范围内的元素。tag = ‘<a href="http://www.python.org">Python web site</a>‘  tag[9:30]=’<a href="http://www.python.org&/#39;">http://www.python.org&#39;</a>  tag[32:-4]=’Python web site’  </p></li><li><p>numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </p><ul><li>numbers[3:6] [4, 5, 6]  numbers[0:1] [1]   numbers[-3:-1] =[8, 9]  numbers[-3:0]=[]   </li><li>numbers[-3:]=[8, 9, 10]   numbers[:3]=[1, 2, 3]  numbers[:]=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </li></ul></li><li><p>执行切片操作时，你显示或隐式地指定起点和终点，但通常省略另一个参数即步长。</p><ul><li>numbers[0:10:1]=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </li><li>numbers[0:10:2]=[1, 3, 5, 7, 9]</li><li>numbers[3:6:3]=[4]  </li></ul></li><li><p>显式地指定步长时，也可使用前述简写。例如，要从序列中每隔3个元素提取1个，只需提供<br>步长4即可。  numbers[::4]=[1, 5, 9]  </p></li><li><p>当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素。复数步长优先级高于切片</p><ul><li>numbers[8:3:-1]=[9, 8, 7, 6, 5]  </li><li>numbers[10:0:-2]=[10, 8, 6, 4, 2]  </li><li>numbers[0:10:-2] =[]</li><li>numbers[::-2]=[10, 8, 6, 4, 2]  </li><li>numbers[5::-2] =[6, 4, 2]  </li><li>numbers[:5:-2] =[10, 8]  </li></ul></li><li><p>序列相加：可使用加法运算符来拼接序列。 </p><ul><li>[1, 2, 3] + [4, 5, 6] =[1, 2, 3, 4, 5, 6]   </li><li>‘Hello,’ + ‘world!’ =’Hello, world!’  </li><li>[1, 2, 3] + ‘world!’  =error（错误）</li><li>从错误消息可知，不能拼接列表和字符串，虽然它们都是序列。一般而言，不能拼接不同类<br>型的序列。  </li></ul></li><li><p>将序列与数x相乘时，将重复这个序列x次来创建一个新序列： </p><ul><li>‘python’ * 5  =’pythonpythonpythonpythonpython’  </li><li>[42] * 10 =[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]  </li></ul></li><li><p>要将列表的长度初始化为10  sequence = [None] * 10  </p></li><li><p># 在位于屏幕中央且宽度合适的方框内打印一个句子<br>sentence = input(“Sentence: “)<br>screen_width = 80<br>text_width = len(sentence)<br>box_width = text_width + 6<br>left_margin = (screen_width - box_width) // 2<br>print()<br>print(‘ ‘ * left_margin + ‘+’ + ‘-‘ * (box_width-2) + ‘+’)<br>print(‘ ‘ * left_margin + ‘| ‘ + ‘ ‘ * text_width + ‘ |’)<br>print(‘ ‘ * left_margin + ‘| ‘ + sentence + ‘ |’)<br>print(‘ ‘ * left_margin + ‘| ‘ + ‘ ‘ * text_width + ‘ |’)<br>print(‘ ‘ * left_margin + ‘+’ + ‘-‘ * (box_width-2) + ‘+’)<br>print()<br>这个程序的运行情况类似于下面这样：<br>Sentence: He’s a very naughty boy!</p><p>+—————————–+<br>| |<br>| He’s a very naughty boy! |<br>| |<br>+—————————–+  </p></li><li><p>要检查特定的值是否包含在序列中，可使用运算符in。  它检查是否满足指定的条件，并返回相应的值：满足时返回True，<br>不满足时返回False。这样的运算符称为布尔运算符，而前述真值称为布尔值。  </p><ul><li>permissions = ‘rw’   ‘w’ in permissions   True  </li></ul></li><li><p>列表python的主力</p><ul><li>修改列表：给元素赋值   x = [1, 1, 1]   x[1] = 2   x=[1, 2, 1]  </li><li>删除元素：names = [‘Alice’, ‘Beth’, ‘Cecil’, ‘Dee-Dee’, ‘Earl’]  del names[2]  names =[‘Alice’, ‘Beth’, ‘Dee-Dee’, ‘Earl’]  </li><li>给切片赋值：name = list(‘Perl’)  name[2:] = list(‘ar’)   name =[‘P’, ‘e’, ‘a’, ‘r’]  </li><li>append：将一个对象附加到列表末尾。lst = [1, 2, 3]  lst.append(4)  lst =[1, 2, 3, 4]  </li><li>clear：清空列表内容。lst = [1, 2, 3]  lst.clear()  lst=[]</li><li>copy:复制列表</li><li>count计算指定元素在列表中出现了多少次[‘to’, ‘be’, ‘or’, ‘not’, ‘to’, ‘be’].count(‘to’) =2</li><li>extned可以将多个值附加到列表末尾。a = [1, 2, 3]  b = [4, 5, 6]  a.extend(b)   a=[1, 2, 3, 4, 5, 6]  </li><li>index在列表中查找第一次出现索引knights = [‘We’, ‘are’, ‘the’, ‘knights’, ‘who’, ‘say’, ‘ni’]  knights.index(‘who’) =4</li><li>insert将对象插入列表numbers = [1, 2, 3, 5, 6, 7]   numbers.insert(3, ‘four’)  numbers =[1, 2, 3, ‘four’, 5, 6, 7]  </li><li>pop从列表中删除一个元素（末尾为最后一个元素），并返回这一元素。x = [1, 2, 3]  x.pop()=3</li><li>使用pop可实现一种常见的数据结构–栈。栈就像一叠盘子。最后加入的盘子最先取走。称为后进先出。</li><li>remove用于删除第一个为指定值的元素。x = [‘to’, ‘be’, ‘or’, ‘not’, ‘to’, ‘be’]  x.remove(‘be’)  x =[‘to’, ‘or’, ‘not’, ‘to’, ‘be’]  </li><li>reverse按相反顺序排列列表中的元素x=[1, 2, 3]  x.reverse()  x=[3, 2, 1]  </li><li>sort方法用于对列表就地排序意味着对原来的列表进行修改，使其元素按序列排序，而不是返回排序后的列表的副本。</li><li>x = [4, 6, 2, 1, 7, 9]  x.sort()   x=[1, 2, 4, 6, 7, 9]  </li><li>高级排序：方法sort接受两个可选参数：key和reverse x = [‘aardvark’, ‘abalone’, ‘acme’, ‘add’, ‘aerate’]  x.sort(key=len)  x=[‘add’, ‘acme’, ‘aerate’, ‘abalone’, ‘aardvark’]   x = [4, 6, 2, 1, 7, 9]  x.sort(reverse=True)  x=[9, 7, 6, 4, 2, 1]  </li></ul></li></ol><h1 id="三-字符串"><a href="#三-字符串" class="headerlink" title="三.字符串"></a>三.字符串</h1><ol><li><p>所有标准序列操作（索引，切片，乘法，成员资格检查，长度，最小值和最大值）都适用于字符串，但字符串是不可变的因此元素赋值和切片赋值是非法的。</p></li><li><p>format=’Hello,%s,%s enough for you?’ % (‘world’,’Hot’)  %s称为转换说明符，指出了要将值插入什么地方。</p></li><li><p>“{3} {0} {2} {1} {3} {0}”.format(“be”, “not”, “or”, “to”)  </p><ul><li>“{foo} {} {bar} {}”.format(1, 2, bar=4, foo=3)  =’3 1 4 2’  </li><li>“{foo} {1} {bar} {0}”.format(1, 2, bar=4, foo=3)  =’3 2 4 1’  </li><li>fullname = [“Alfred”, “Smoketoomuch”]  “Mr {name[1]}”.format(name=fullname) =’Mr Smoketoomuch’  </li><li>&gt;&gt;&gt;import math<br>&gt;&gt;&gt; tmpl = “The {mod.<strong>name</strong>} module defines the value {mod.pi} for π “<br>&gt;&gt;&gt; tmpl.format(mod=math)<br>‘The math module defines the value 3.141592653589793 for π ‘  </li></ul></li><li><p>基本转换</p><ul><li>你还可指定要转换的值是哪种类型，更准确地说，是要将其视为哪种类型。例如，你可能提<br>供一个整数，但将其作为小数进行处理。为此可在格式说明（即冒号后面）使用字符f（表示定<br>点数）。<br>&gt;&gt;&gt; “The number is {num}”.format(num=42)<br>‘The number is 42’<br>&gt;&gt;&gt; “The number is {num:f}”.format(num=42)<br>‘The number is 42.000000’<br>你也可以将其作为二进制数进行处理。<br>&gt;&gt;&gt; “The number is {num:b}”.format(num=42)<br>‘The number is 101010  </li><li>b 将整数表示为二进制数<br>c 将整数解读为Unicode码点<br>d 将整数视为十进制数进行处理，这是整数默认使用的说明符<br>e 使用科学表示法来表示小数（用e来表示指数）<br>E 与e相同，但使用E来表示指数<br>f 将小数表示为定点数<br>F 与f相同，但对于特殊值（ nan和inf），使用大写表示<br>g 自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数<br>G 与g相同，但使用大写来表示指数和特殊值<br>n 与g相同，但插入随区域而异的数字分隔符<br>o 将整数表示为八进制数<br>s 保持字符串的格式不变，这是默认用于字符串的说明符<br>x 将整数表示为十六进制数并使用小写字母<br>X 与x相同，但使用大写字母<br>% 将数表示为百分比值（乘以100，按说明符f设置格式，再在后面加上%）</li></ul></li><li><p>宽度、精度和千位分隔符  </p><ul><li><p>设置浮点数（或其他更具体的小数类型）的格式时，默认在小数点后面显示6位小数，并根<br>据需要设置字段的宽度，而不进行任何形式的填充。当然，这种默认设置可能不是你想要的，在<br>这种情况下，可根据需要在格式说明中指定宽度和精度。<br>宽度是使用整数指定的，如下所示：<br>&gt;&gt;&gt; “{num:10}”.format(num=3)<br>‘                 3’<br>&gt;&gt;&gt; “{name:10}”.format(name=”Bob”)<br>‘Bob             ‘<br>如你所见，数和字符串的对齐方式不同。对齐将在下一节介绍。  </p></li><li><p>精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点。<br>&gt;&gt;&gt; “Pi day is {pi:.2f}”.format(pi=pi)<br>‘Pi day is 3.14  </p></li><li><p>可同时指定宽度和精度。  &gt;&gt;&gt; “{pi:10.2f}”.format(pi=pi)<br>‘                 3.14’  </p></li><li><p>format=”{:.4}”.format(“Guido van Rossum”)<br>format=Guid</p></li><li><p>可使用逗号来指出你要添加千位分隔符。<br>&gt;&gt;&gt; ‘One googol is {:,}’.format(10**100)<br>‘One googol is 10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,00<br>0,000,000,000,000,000,000,000,000,000,000,000,000,000,000’  </p><p>同时指定其他格式设置元素时，这个逗号应放在宽度和表示精度的句点之间①。  </p><p> format=”{:10,.2f}”.format(10**10)=10,000,000,000.00</p></li></ul></li><li><p>符号、对齐和用 0 填充  </p><ul><li>‘{:010.2f}’.format(pi)  =’0000003.14’   用0填充空值</li><li>要指定左对齐、右对齐和居中，可分别使用&lt;、 &gt;和^。  <ul><li>&gt;&gt;&gt; print(‘{0:&lt;10.2f}\n{0:^10.2f}\n{0:&gt;10.2f}’.format(pi))<br>3.14<pre><code>    3.14            3.14  </code></pre></li><li>可以使用填充字符来扩充对齐说明符，这样将使用指定的字符而不是默认的空格来填充  </li><li>&gt;&gt;&gt; “{:$^15}”.format(“ WIN BIG “)<br>‘$$$ WIN BIG $$$’  </li></ul></li></ul></li><li><p>字符串方法</p><ul><li><p>center  方法center通过在两边添加填充字符（默认为空格）让字符串居中。  &gt;&gt;&gt; “The Middle by Jimmy Eat World”.center(39, “<em>“)’****</em>The Middle by Jimmy Eat World*****’  </p></li><li><p>find方法find在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。<br>&gt;&gt;&gt; ‘With a moo-moo here, and a moo-moo there’.find(‘moo’)<br>7  </p></li><li><p>join是一个非常重要的字符串方法，其作用与split相反，用于合并序列的元素。  </p><p>&gt;&gt;&gt; seq = [‘1’, ‘2’, ‘3’, ‘4’, ‘5’]<br>&gt;&gt;&gt; sep.join(seq) # 合并一个字符串列表<br>‘1+2+3+4+5’<br>&gt;&gt;&gt; dirs = ‘’, ‘usr’, ‘bin’, ‘env’<br>&gt;&gt;&gt; ‘/‘.join(dirs)<br>‘/usr/bin/env’<br>&gt;&gt;&gt; print(‘C:’ + ‘\‘.join(dirs))<br>C:\usr\bin\env  </p><p>如你所见，所合并序列的元素必须都是字符串。  </p></li><li><p>lower  方法lower返回字符串的小写版本  title方法title返回字符串的词首大写版本 </p></li><li><p>replace：方法replace将指定子串都替换为另一个字符串，并返回替换后的结果。  </p></li><li><p>split是一个非常重要的字符串方法，其作用与join相反，用于将字符串拆分为序列。  </p><p>&gt;&gt;&gt; ‘1+2+3+4+5’.split(‘+’)<br>[‘1’, ‘2’, ‘3’, ‘4’, ‘5’]  </p></li><li><p>strip  方法strip将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果。<br>&gt;&gt;&gt; ‘           internal whitespace is kept          ‘.strip()<br>‘internal whitespace is kept’  </p></li><li><p>translate  方法translate与replace一样替换字符串的特定部分，但不同的是它只能进行单字符替换。<br>这个方法的优势在于能够同时替换多个字符，因此效率比replace高。  </p><p>使用translate前必须创建一个转换表。为此必须将字符c和s分别替换为k和z。  </p><p>&gt;&gt;&gt; table = str.maketrans(‘cs’, ‘kz’)  </p><p>创建转换表后，就可将其用作方法translate的参数。<br>&gt;&gt;&gt; ‘this is an incredible test’.translate(table)<br>‘thiz iz an inkredible tezt’  </p></li></ul></li><li><p>基本的字典操作</p><ul><li><p>可使用函数dict①从其他映射（如其他字典）或键值对序列创建字典。<br>&gt;&gt;&gt; items = [(‘name’, ‘Gumby’), (‘age’, 42)]<br>&gt;&gt;&gt; d = dict(items)<br>&gt;&gt;&gt; d<br>{‘age’: 42, ‘name’: ‘Gumby’}<br>&gt;&gt;&gt; d[‘name’]<br>‘Gumby’<br>还可使用关键字实参来调用这个函数，如下所示：<br>&gt;&gt;&gt; d = dict(name=’Gumby’, age=42)<br>&gt;&gt;&gt; d<br>{‘age’: 42, ‘name’: ‘Gumby’}  </p></li><li><p>字典的基本行为在很多方面都类似于序列。<br> len(d)返回字典d包含的项（键值对）数。<br> d[k]返回与键k相关联的值。<br> d[k] = v将值v关联到键k。<br> del d[k]删除键为k的项。<br> k in d检查字典d是否包含键为k的项。<br>虽然字典和列表有多个相同之处，但也有一些重要的不同之处。</p></li><li><p> 键的类型：字典中的键可以是整数，但并非必须是整数。字典中的键可以是任何不可变<br>的类型，如浮点数（实数）、字符串或元组。<br> 自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。<br>然而，如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。<br> 成员资格：表达式k in d（其中d是一个字典）查找的是键而不是值，而表达式v in l（其<br>中l是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自<br>然。毕竟如果字典包含指定的键，检查相应的值就很容易。</p></li></ul></li><li><p>字典方法</p><ul><li><p>clear 方法clear删除所有的字典项，这种操作是就地执行的（就像list.sort一样），因此什么都不<br>返回（或者说返回None）。 </p></li><li><p>copy： 方法copy返回一个新字典，其包含的键值对与原来的字典相同（这个方法执行的是浅复制，<br>因为值本身是原件，而非副本）。</p></li><li><p>fromkeys  方法fromkeys创建一个新字典，其中包含指定的键，且每个键对应的值都是None。  </p></li><li><p>&gt;&gt;&gt; {}.fromkeys([‘name’, ‘age’])<br>{‘age’: None, ‘name’: None}  </p></li><li><p>如果你不想使用默认值None，可提供特定的值。<br>&gt;&gt;&gt; dict.fromkeys([‘name’, ‘age’], ‘(unknown)’)<br>{‘age’: ‘(unknown)’, ‘name’: ‘(unknown)’}  </p></li><li><p>get 方法get为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发<br>错误。</p></li><li><p>items方法items返回一个包含所有字典项的列表，其中每个元素都为(key, value)的形式。字典项<br>在列表中的排列顺序不确定。  </p><p>&gt;&gt;&gt; d = {‘title’: ‘Python Web Site’, ‘url’: ‘<a href="http://www.python.org&/#39;">http://www.python.org&#39;</a>, ‘spam’: 0}<br>&gt;&gt;&gt; d.items()<br>dict_items([(‘url’, ‘<a href="http://www.python.org&/#39;">http://www.python.org&#39;</a>), (‘spam’, 0), (‘title’, ‘Python Web Site’)])  </p><p>返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代（迭代将在第5章详细介绍）。<br>另外，你还可确定其长度以及对其执行成员资格检查。</p></li><li><p>keys：方法keys返回一个字典视图，其中包含指定字典中的键  </p></li><li><p>pop：方法pop可用于获取与指定键相关联的值，并将该键值对从字典中删除。  </p></li><li><p>popitem ：方法popitem类似于list.pop，但list.pop弹出列表中的最后一个元素，而popitem随机地弹  </p><p>出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效<br>地方式逐个删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 </p></li><li><p>setdefault  方法setdefault有点像get，因为它也获取与指定键相关联的值，但除此之外， setdefault<br>还在字典不包含指定的键时，在字典中添加指定的键值对。  </p><p>如你所见，指定的键不存在时， setdefault返回指定的值并相应地更新字典。如果指定的键<br>存在，就返回其值，并保持字典不变。与get一样，值是可选的；如果没有指定，默认为None。<br>&gt;&gt;&gt; d = {}<br>&gt;&gt;&gt; print(d.setdefault(‘name’))<br>None<br>&gt;&gt;&gt; d<br>{‘name’: None}  </p></li><li><p>update  方法update使用一个字典中的项来更新另一个字典。  对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。  </p></li><li><p>values  方法values返回一个由字典中的值组成的字典视图。不同于方法keys，方法values返回的视<br>图可能包含重复的值。  </p></li></ul></li></ol><h1 id="四。条件，循环及其他语句"><a href="#四。条件，循环及其他语句" class="headerlink" title="四。条件，循环及其他语句"></a>四。条件，循环及其他语句</h1><ol><li><p>导入是重命名：import math as foobar  </p></li><li><p>这里执行的操作称为序列解包（或可迭代对象解包）：将一个序列（或任何可迭代<br>对象）解包，并将得到的值存储到一系列变量中。下面用例子进行解释。  </p><p>&gt;&gt;&gt; values = 1, 2, 3<br>&gt;&gt;&gt; values<br>(1, 2, 3)<br>&gt;&gt;&gt; x, y, z = values<br>&gt;&gt;&gt; x<br>1  </p><ul><li><p>这在使用返回元组（或其他序列或可迭代对象）的函数或方法时很有用。假设要从字典中随<br>便获取（或删除）一个键值对，可使用方法popitem，它随便获取一个键值对并以元组的方式<br>返回。接下来，可直接将返回的元组解包到两个变量中。  </p><p>&gt;&gt;&gt; scoundrel = {‘name’: ‘Robin’, ‘girlfriend’: ‘Marion’}<br>&gt;&gt;&gt; key, value = scoundrel.popitem()<br>&gt;&gt;&gt; key<br>‘girlfriend’<br>&gt;&gt;&gt; value<br>‘Marion’  </p></li><li><p>可使用星号运算符（ *）来收集多余的值，这样无需确保值和变量的个数相同，如下例所示：<br>&gt;&gt;&gt; a, b, *rest = [1, 2, 3, 4]<br>&gt;&gt;&gt; rest<br>[3, 4]<br>还可将带星号的变量放在其他位置。<br>&gt;&gt;&gt; name = “Albus Percival Wulfric Brian Dumbledore”<br>&gt;&gt;&gt; first, *middle, last = name.split()<br>&gt;&gt;&gt; middle<br>[‘Percival’, ‘Wulfric’, ‘Brian’]<br>赋值语句的右边可以是任何类型的序列，但带星号的变量最终包含的总是一个列表。在变量<br>和值的个数相同时亦如此。<br>&gt;&gt;&gt; a, *b, c = “abc”<br>&gt;&gt;&gt; a, b, c<br>(‘a’, [‘b’], ‘c’)<br>这种收集方式也可用于函数参数列表中（参见第6章）。</p></li><li><p>增强赋值：可以不编写代码x = x + 1，而将右边表达式中的运算符（这里是+）移到赋值运算符（ =）</p><p>的前面，从而写成x += 1。这称为增强赋值，适用于所有标准运算符，如*、 /、 %等。    </p><p>&gt;&gt;&gt; x = 2<br>&gt;&gt;&gt; x += 1<br>&gt;&gt;&gt; x *= 2<br>&gt;&gt;&gt; x<br>6  </p></li></ul></li><li><p>并行迭代<br>有时候，你可能想同时迭代两个序列。假设有下面两个列表：<br>names = [‘anne’, ‘beth’, ‘george’, ‘damon’]<br>ages = [12, 45, 32, 102]<br>如果要打印名字和对应的年龄，可以像下面这样做：<br>for i in range(len(names)):<br>print(names[i], ‘is’, ages[i], ‘years old’)<br>i是用作循环索引的变量的标准名称。一个很有用的并行迭代工具是内置函数zip，它将两个<br>序列“缝合”起来，并返回一个由元组组成的序列。返回值是一个适合迭代的对象，要查看其内<br>容，可使用list将其转换为列表。<br>&gt;&gt;&gt; list(zip(names, ages))<br>[(‘anne’, 12), (‘beth’, 45), (‘george’, 32), (‘damon’, 102)]<br>“缝合”后，可在循环中将元组解包。  </p><p>for name, age in zip(names, ages):<br>print(name, ‘is’, age, ‘years old’)  </p></li><li><p>列表推导：是一种从其他列表创建列表的方式，类似于数学中的集合推导。列表推导的工作原<br>理非常简单，有点类似于for循环。  </p><ul><li><p>&gt;&gt;&gt; [x * x for x in range(10)]<br>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]  </p></li><li><p>这个列表由range(10)内每个值的平方组成，非常简单吧？如果只想打印那些能被3整除的平<br>方值，该如何办呢？可使用求模运算符：如果y能被3整除， y 3 % 将返回0（请注意，仅当x能被3<br>整除时， x<em>x才能被3整除）。为实现这种功能，可在列表推导中添加一条if语句。<br>&gt;&gt;&gt; [x\</em>x for x in range(10) if x% 3 == 0]<br>[0, 9, 36, 81]  </p></li><li><p>还可添加更多的for部分。<br>&gt;&gt;&gt; [(x, y) for x in range(3) for y in range(3)]<br>[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] </p></li></ul></li><li><p>因为在Python中代码块不能为空。要修复这个问题，只需在中间的代码<br>块中添加一条pass语句即可。  </p></li><li><p>没有任何名称与之相关联，就也无法获取或使用它了。因此，智慧无穷的Python解释器直接将其删除。这被<br>称为垃圾收集。  </p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一。基础知识&quot;&gt;&lt;a href=&quot;#一。基础知识&quot; class=&quot;headerlink&quot; title=&quot;一。基础知识&quot;&gt;&lt;/a&gt;一。基础知识&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;2+2=4 ,1/2=0.5 1/1=1.0 python / 除法保留小数点后一位，即浮点数。</summary>
      
    
    
    
    <category term="python基础教程" scheme="http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="python基础教程笔记一" scheme="http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统笔记二</title>
    <link href="http://yoursite.com/2020/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%BA%8C/</id>
    <published>2020-09-17T03:54:39.000Z</published>
    <updated>2020-09-22T09:09:07.511Z</updated>
    
    <content type="html"><![CDATA[<p>一,寻址与字节顺序</p><ol><li><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用的字节中最小的地址。例如，int变量x的地址为0x100（假设数据类型int为32位表示）x 的4个字节将被存储在内存0x00,0x01,0x02,0x03位置，地址取最小的位置。</p></li><li><p>某些机器选择在内存中 按照从最低有效字节到最高有效字节的顺序存储对象—-最低有效字节在最前面称为小端法。</p><p>小端法：      0x100                0x101                0x102                0x103            —</p><p>​                        01                        23                    45                        67</p><p>另一些机器则按照从最高有效字节到最低有效字节的顺序存储—–最高有效字节在前面的方式称为大端法。</p><p>大端法：     0x100                0x101                0x102                0x103            —</p><p>​                        67                    45                        23                        01</p><h6 id="32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址"><a href="#32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址" class="headerlink" title="32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址"></a>32位系统和64位系统字符串存储位数不同转化可能遇到问题，32位是字节地址，64位使用8字节地址</h6></li><li><p>布尔代数的运算。二进制1和0表示逻辑值TRUE或者FALSE，而运算符~，&amp;，|，^ 分别表示逻辑NOT(取反)，AND,OR,非（异或）</p></li><li><h3 id="切勿混用带符号类型和无符号类型"><a href="#切勿混用带符号类型和无符号类型" class="headerlink" title="切勿混用带符号类型和无符号类型"></a>切勿混用带符号类型和无符号类型</h3><p>如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成为无符号数。例如一个形如 a*b 的式子中，如果 a=-1,b=1，而且a，b都是int类型，则表达式的值显然为-1，然而如果a是int，而b是unsigned int，则结果须视在当前机器上int所占位数而定，在32位计算机系统中，结果是4294967295。</p></li><li><p>不同精度大数据量转换时需慎重</p></li></ol><p>二,预防蠕虫与病毒</p><ol><li>蠕虫：可以自己运行，并且能够将自己的等效副本传播到其他机器。病毒：能将自己添加到包括操作系统在内的其他程序中，不能独立运行。通过输入给程序一个字符串，包含一些可执行代码的字节编码，称为攻击代码(病毒)。</li><li>栈随机化：栈随机化的思想是使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，栈地址不同。防止被相同病毒一起破坏。实现方法是：程序开始时，在栈上分配一段0-n字节之间的随机大小的空间</li><li>栈破坏检测：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（cannary）值，也称哨兵值，是在程序每次运行时随机产生的，因此攻击者没有简单的方法知道他是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者函数调用的某个函数的某个操作改变了。如果是的，那么程序异常终止。</li><li>限制可执行代码区域：最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制只允许读和写。虚拟内存空间在逻辑上被分成了页，典型的每页是2048或者4096字节。</li></ol><p>三,优化程序性能</p><ol><li>减少过程调用</li><li>消除不必要的内存引用</li><li>提高并行性</li></ol><p>四,虚拟内存</p><ol><li><p>虚拟内存是计算机系统最重要的概念之一。它成功的原因是因为它是沉默地，自动工作的，不需要程序员干涉的。</p><ul><li>虚拟内存是核心的：虚拟内存遍及计算机系统所有层面</li><li>虚拟内存是强大的。虚拟内存给予应用程序强大的能力，可以创建和销毁内存片，将内存片映射到磁盘文件的某个部分，以及其他进程共享内存。</li><li>虚拟内存是危险的。每次程序引用一个变量，间接引用一个指针，动态分配程序时，它就会和虚拟内存发生交互。如果虚拟内存使用不当，应用将遇到复杂危险的与内存有关的错误。</li></ul></li><li><p>计算机系统的主存被组织成一个有M个连续的字节大小的单元组成的数组，第一个字节地址0，最后一个字节地址M-1。每个字节都有唯一的物理地址（PA）。</p></li><li><p>虚拟寻址：cpu通过生成一个虚拟地址（VA）来访问主存，虚拟地址通过地址翻译转换为物理地址。</p></li><li><p>地址空间：是一个非负数整数地址的有序集合。如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。</p></li><li><p>虚拟内存作为缓存的工具：概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。VM系统将虚拟内存分割称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2的p次方字节。类似地，物理内存被分割为物理页。</p></li><li><p>在任意时刻虚拟页的集合都分为三个不相交的子集：</p><ul><li>未分配的：VM（虚拟机）系统还未分配的页。未分配的块没有任何数据和它们相关联，因此也就不占任何磁盘空间。</li><li>缓存的：当前已缓存在物理内存中的已分配页。</li><li>未缓存的：未缓存在物理内存中的已分配页。</li></ul></li><li><p>访问虚拟内存比访问磁盘时间短。</p></li><li><ul><li><h6 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h6><p>​    通过把一部分暂时不用的内存信息放到硬盘上</p><p>​    局部性原理，程序运行时候只有部分<strong>必要的信息装入内存</strong></p><p>​    内存中暂时<strong>不需要的内容放到硬盘上</strong>，当需要的时候从新交换回来</p><p><strong>系统似乎提供了比实际内存大得多的容量，称之为虚拟内存</strong></p><p> （1）<strong>局部性</strong>分为时间局部性和空间局部性</p><p>​       <strong>时间局部性</strong>就是如果一块内存被访问的时候，很有可能在不远的将来还会被访问</p><p>   <strong>空间局部性</strong>就是如果一块内存被访问，那么周围的内存也很有可能被访问</p></li><li><h6 id="什么是内存抖动（颠簸）-虚拟内存工作集的大小超过了物理内存大小，程序性能极慢"><a href="#什么是内存抖动（颠簸）-虚拟内存工作集的大小超过了物理内存大小，程序性能极慢" class="headerlink" title="什么是内存抖动（颠簸）:虚拟内存工作集的大小超过了物理内存大小，程序性能极慢"></a>什么是内存抖动（颠簸）:虚拟内存工作集的大小超过了物理内存大小，程序性能极慢</h6><p>本质是频繁的页调度行为</p><p>频繁的页调度，进程不断产生缺页中断</p><p>置换一个页，又不断再次需要这个页</p><p><strong>运行程序太多；页面替换策略不好。通过杀掉一些无关的进程(终止进程)或者增加物理内存解决</strong></p></li></ul></li><li><p>输入/输出（I/O）是在主存和外部设备（例如磁盘驱动器，终端和网络之间）之间复制数据的过程。</p><p>输入操作是从I/O设备复制数据到主存，而输出操作是从主存复制数据到I/O设备。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一,寻址与字节顺序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用的字节中最小的地址。例如，int变量x的地址为0x100（假设数据类型int为32位表示）x 的4个字节将被存储在内存0x00,0x01,0x02,</summary>
      
    
    
    
    <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记二" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统笔记一</title>
    <link href="http://yoursite.com/2020/09/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/09/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2020-09-15T06:24:10.000Z</published>
    <updated>2020-09-16T08:49:27.834Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一，移位运算"><a href="#一，移位运算" class="headerlink" title="一，移位运算"></a>一，移位运算</h5><ol><li>1&lt;&lt;2+3&lt;&lt;4 =1&lt;&lt;2 + 3&lt;&lt;4 =1乘2的平方+3乘2的4次方=4+3*16=52</li></ol><h5 id="二，原码反码补码"><a href="#二，原码反码补码" class="headerlink" title="二，原码反码补码"></a>二，原码反码补码</h5><ol><li><p>原码：为二进制的数，如：10   原码0000 1010</p><p>反码：正数与原码相同，如：10   反码0000 1010</p><p>负数为原码0变1，1变0，（符号位不变）如：</p><p>-10 原码1000 1010</p><p>​       反码1111 0101</p><p>补码：正数的补码与原码相同，如：</p><p>10   补码0000 1010</p><p>负数的补码为反码加1，如：-10   </p><p>反码：1111 0101   </p><p>补码：1111 0110</p></li><li><p>计算机中存储的都是补码，因为计算机中只有加法机，所以所有减法运算，都必须用加法进行。</p></li><li><p>用补数代替原数，可把减法转变为加法。出现的进位就是模，此时的进位，就应该忽略不计。</p></li><li><p>二进制下，有多少位数参加运算，模就是在 1 的后面加上多少个 0。</p></li><li><p>补码就是按照这个要求来定义的：正数不变，负数即用模减去绝对值。</p></li><li><p>计算机减法运算时因为-0和0希望只出现一个且满足正数负数相加等于0，所以存储的都是补码</p><p>举例，3和（-3）相加，0011 + 1101 =10000，丢掉最高位，就是0000（0）</p><p>4和（-3）相加，0100 + 1101 =0001</p></li><li><p>参考<a href="https://blog.csdn.net/zl1zl2zl3/article/details/53327216">https://blog.csdn.net/zl1zl2zl3/article/details/53327216</a></p></li></ol><h5 id="三-AmdahL定律"><a href="#三-AmdahL定律" class="headerlink" title="三.AmdahL定律"></a>三.AmdahL定律</h5><ol><li><p>Gene Amdahl 计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察称为Amdahl定律。主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行应用程序需要时间为T(old).假设系统某部分所需执行时间与该时间的比例为a，而该部分性能提升比例为k。即该部分初始所需时间为aT(old),现在所需时间为aT(old)/K.因此总的执行时间应为：T(new)=(1-a)T(old)+(aT(old))/k=T(old)[(1-a)+a/k]</p><h6 id="由此，加速比S-T-old-T-new-为-S-1-1-a-a-k"><a href="#由此，加速比S-T-old-T-new-为-S-1-1-a-a-k" class="headerlink" title="由此，加速比S=T(old)/T(new) 为 S=1/((1-a)+a/k)"></a><u>由此，加速比S=T(old)/T(new) 为 S=1/((1-a)+a/k)</u></h6><p>举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为60%(a=0.6),其加速比例因子为3（k=3）。则我们可以获得的加速比为1/[0.4+0.6/3]=1.67倍。虽然我们对系统一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分加速比。这就是</p><p>Amdahl定律的主要观点—要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p></li></ol><h5 id="四-信息存储"><a href="#四-信息存储" class="headerlink" title="四.信息存储"></a>四.信息存储</h5><ol><li><p>大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中的位(bit)比特。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存每个字节都由唯一的数字来标识，称为他的地址，所有可能地址的集合就称为虚拟地址空间。</p></li><li><p>16进制数字对应关系：    0         1        2        3        4           5        6        7        8        9         A          B          C          D          E         F</p><p>10进制数字对应关系：    0         1        2        3        4           5        6        7        8        9        10        11        12        13        14        15        </p><p>二进制数字对应关系：0000   0001   0010  0011  0100  0101 0110   0111  1000  1001  1010  1011    1100    1101     1110   1111</p><p>在c语言中0x被默认为16进制数字</p><p>16进制和10进制转化：314156=19634*16+12          (C)</p><p>​                                       19634=1227*16+2               (2)</p><p>​                                          1227=76*16+11                (B)</p><p>​                                              76=4*16+12                  (C)</p><p>​                                                4=0*16+4                     (4)</p><p>314156的16进制为：0x4CB2C   </p><p>0x4CB2C  的10进制为：4×16的4次方+12×16的3次方+11×16的平方+2×16+12=314156</p></li><li><p>字数据大小：每台计算机都有一个字长（word size） ，指明指针数据的标称大小。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对一个字长为w位的机器而言，虚拟地址的范围为0-2w次方-1，程序最多访问2w次方个字节。最近出现了大规模从32位字长机器到64位的迁移。32位字长限制虚拟地址空间为4千兆字节（写作4GB），也就是说刚刚超过4×10的9次方字节。扩展到64位字长使得虚拟地址为16EB，大约1.84×10的19次方字节。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;一，移位运算&quot;&gt;&lt;a href=&quot;#一，移位运算&quot; class=&quot;headerlink&quot; title=&quot;一，移位运算&quot;&gt;&lt;/a&gt;一，移位运算&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;1&amp;lt;&amp;lt;2+3&amp;lt;&amp;lt;4 =1&amp;lt;&amp;lt;2 + 3&amp;lt;&amp;lt;4 =</summary>
      
    
    
    
    <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="笔记一" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="http://yoursite.com/2020/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2020/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-09-11T01:32:12.000Z</published>
    <updated>2020-09-11T07:21:37.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-系统硬件组成"><a href="#一-系统硬件组成" class="headerlink" title="一.系统硬件组成"></a>一.系统硬件组成</h1><ol><li><p>总线</p><p>贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字节中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4字节（32位），要么是8字节（64位）。</p></li><li><p>I/O 设备</p><p>I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个IO设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序hello就存放在磁盘上。</p><p>每个I/O设备都通过1个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统 的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，他们的功能都是在I/O总线和I/O设备之间传递信息。</p></li><li><p>主存</p><p>主存是一个临时存储设备，在处理执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性字节数组，每个字节有唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与c程序变量相对应的数据项大小是根据类型变化的。比如，运行linux的x86-64机器上，short类型的数据需要两个字节，int和float 类型需要4个字节，而long和double 类型需要8个字节。</p></li><li><p>处理器</p><p>中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，pc都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其执行下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作然后更新pc，使其指向下一条命令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</p><p>​    这样的简单操作并不多，他们围绕着主存，寄存器文件和算术/逻辑单元(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是cpu可能的执行操作。</p><ul><li>加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（pc）中，以覆盖pc中原来的值。</li></ul></li></ol><h1 id="二-程序执行"><a href="#二-程序执行" class="headerlink" title="二.程序执行"></a>二.程序执行</h1><ol><li>运行hello程序：当我们在键盘上输入字符串‘./hello’ 后，shell程序将字符逐一读入寄存器，再把它放到内存中。当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器存取DMA技术，数据可以不通过处理器直接从磁盘到达主存。一旦目标hello中的代码数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。</li><li>系统花费了大量的时间把信息从一个地方挪到另一个地方。hello程序的机器指令最初是存放在磁盘上，当程序加载时，他们被复制到主存，当处理器运行程序时，指令又从主存复制到处理器。这些复制就是开销，减慢了程序真正的工作。因此，系统设计者的主要目标就是使这些复制操作尽可能快的完成。</li><li>根据机械原理，较大的存储设备要比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备。</li><li>进程：从一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻主存的部分。当读写文件时，他就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，他是系统管理全部进程所用代码和数据结构的集合。</li><li>线程：一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。因为多线程之间比多进程之间更容易共享数据，也因为线程一般比进程更高效，多处理器的时候 多线程并发更快。</li><li>虚拟内存：虚拟内存是一个抽象的概念，他为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。构成：<ul><li>程序代码和数据。对所有进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello</li><li>堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用标准库函数时，堆可以在运动时动态的扩展和伸缩。</li><li>栈。位于用户虚拟地址空间顶部的就是用户栈。</li><li>内核虚拟内存。地址空间顶部为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义函数。相反他们必须调用内核来执行这些操作。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-系统硬件组成&quot;&gt;&lt;a href=&quot;#一-系统硬件组成&quot; class=&quot;headerlink&quot; title=&quot;一.系统硬件组成&quot;&gt;&lt;/a&gt;一.系统硬件组成&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;总线&lt;/p&gt;
&lt;p&gt;贯穿整个系统的是一组电子管道，称作总线，它携带信息字节</summary>
      
    
    
    
    <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="概要:计算机系统漫游" scheme="http://yoursite.com/tags/%E6%A6%82%E8%A6%81-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>第二篇</title>
    <link href="http://yoursite.com/2020/09/09/%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
    <id>http://yoursite.com/2020/09/09/%E7%AC%AC%E4%BA%8C%E7%AF%87/</id>
    <published>2020-09-09T03:06:41.000Z</published>
    <updated>2020-09-10T11:34:10.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-编码"><a href="#一-编码" class="headerlink" title="一.编码"></a>一.编码</h1><p>1.人最伟大的进化就是语言和文字，前者方便我们交流，后者使我们的知识得以保留。但不是什么时候语言都是那么的方便，在离得很远的黑暗中，声音的传播会受到很多干扰。但光不会受到太多干扰反而更加便于观测，但是如何使光成为语言是个问题。</p><p>2.经过漫长的发展人们发现可以通过灯光的闪烁以及一定的间隔来发送信息，例如sos 可以用手电打出三短 三长 三短 来表示，通过这种方式与对照表可以进行加密通讯。而不会被其他人识别，是保密的好方法。但是缺失对照表会让人很头疼，而且很长的句子效率很低。</p><p>3.上述就是摩斯密码，后来用于电报和发送秘密信息。</p><p>4.在漫长的发展中，盲人布莱叶 发明了布莱叶编码，这是一种由空格和凸起形成的文字编码。短语“ you and me”在布莱叶编码中看起来是这样的：  <img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909151604890.png" alt="image-20200909151604890"></p><p>注意，代表同一个单词中的字母的小格用一个小距离分隔，大一些的距离（一般是没有<br>凸点的小格）用来分隔不同的单词。  这为机器编译文字提供了可能。</p><h1 id="二-电"><a href="#二-电" class="headerlink" title="二.电"></a>二.电</h1><p>1.一个原子的电子数通常等于其质子数。但在某种特定环境下，电子能从原子中电离出来，<br>这样电就产生了。  </p><p>2.手电筒电路中的电能显然比电火花或闪电之中的电能要好利用得多。灯泡能稳定持续地<br>亮是因为电子并不是从一点跳到另一点。当电路中的一个原子把一个电子传给邻接的另一个<br>原子时，它又从另一个邻接的原子获得电子，而这个原子又从它的一个邻接原子获得电子，<br>如此依次循环。可见电路中的电就是从原子到原子的电子通路。  </p><p>3.当电报机的键按下时，发生器的电磁铁将可动棒拖下发出“滴”的声音；当键放开时，<br>棒弹回初始位置，发出“嗒”的声音。快速的“嘀嗒”为点，慢速的则为划。字母 V代替接地的电池    </p><p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909172650513.png" alt="image-20200909172650513" style="zoom: 50%;" /><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909172752152.png" alt="image-20200909172752152"></p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909172818212.png" alt="image-20200909172818212" style="zoom:50%;" /><p>4.我们已经发明的这个装置叫重发器或<strong>继电器</strong>。一个继电器就像一个发声装置，输入的电流形成电磁用<br>以拖动金属杆，金属杆作为开关的一个部分连接到外接的导线上。这样，微弱的输入电流被<br>扩大形成比较强的输出电流。  </p><h1 id="三-数字进制"><a href="#三-数字进制" class="headerlink" title="三.数字进制"></a>三.数字进制</h1><p>​    1.因为人的手指是10个所以最早开始的是十进制。计算机普遍使用的是二进制。</p><p>​    2.下面是二进制的前1 6个数以及和它们等值的十进制数：  </p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200909174206671.png" alt="image-20200909174206671" style="zoom:50%;" /><p>在数二进制数的时候，最右边的数字（也称最低位<br>数字）是在 0和1之间变化的。当它每次从 1变到0时，右数第二位数字（也称次低位数字）也<br>要发生变化，或者从 0变到1，或者从 1变到0。每次只要有一个二进制数位的值由 1变到0，紧<br>挨着的高位数字也会发生变化，要么从 0变到1，要么从1变到0。  </p><p>每次十进制加一，在二进制上也要加一，但是二进制最大是一所以当十进制为2时，二进制要进一，类似九进一。所以二进制的2 为0010.</p><p>3.通过将数字系统减少至只有 0和1两个数字的二进制数字系统，我们已经在能够接受的范<br>围内做了深入的讨论。不可能找到比二进制数字系统更简单的数字系统了。二进制数字系统<br>架起了算术与电之间的桥梁。前面各章中，我们所看到的开关、电线、灯泡、继电器等物体<br>都可以表示二进制数 0和1</p><p>4.二进制数与计算机密切相关！<br>大约在1 9 4 8年，美国数学家John Wilder Tukey （生于1 9 1 5年）提前认识到二进制数将在<br>未来几年中随着计算机的流行而发挥更大的作用。他决定创造一个新的、更短的词来代替使<br>用起来很不灵活的五音节词—binary digit。他曾经考虑用 b i g i t或b i n i t，但最后还是选用了短<br>小、简单、精巧且非常可爱的单词 b i t (比特)来代替binary digit这个词。  bit最小的数据单位。</p><p>5.数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。<br>还可以从以下几个方面来理解：<br>(1).字节(Byte)是电脑中表示信息含义的最小单位，因为在通常情况下一个ACSII码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八个位。人们之所以把字节称为电脑中表示信息含义的最小单位，表示最基本的字符，是因为一个位并不能表示我们现实生活中的一个相对完整的信息。另外，内存中运算的最小存储单位是字节，位运算也是在一个字节的存储单位的基础上进行的，所以存储的最小单位可以理解为字节。</p><p>(2).bit是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量称为一比特，是表示信息的最小单位，只有两种状态：0和1。电脑内部的电路工作有高电平和低电平两种状态.所以就用二进制来表示信号，以便计算机识别。所以计算机能传输的最小单位当然是你信号的单位bit，而不是字节，串口最小也有一位传递的。另外数字信息流的基本单位是bit（比特），时间的基本单位是s（秒），因此bit/s（比特/秒）是描述带宽的单位，1bit/s是带宽的基本单位，所谓的带宽其实指的是传输速度的快慢，也就是指在一个固定的时间内（1秒），能通过的最大位数据。</p><h1 id="四-逻辑"><a href="#四-逻辑" class="headerlink" title="四.逻辑"></a>四.逻辑</h1><p>​    1.传统代数的另外一个特点是它总是处理数字，如豆腐的重量或鸭子的数量，火车行驶的<br>​        距离或家庭成员的年龄。是布尔超凡的智慧使代数脱离了数字的概念而变得更加抽象。在布<br>​        尔代数中（布尔的代数最终被这样命名）操作数不是指数字，而是指集（类） 。一个类仅仅表<br>​        示一组事物，也就是后来熟知的集合。</p><ol start="2"><li><p>事实上，在布尔代数中我们并不真正地做加或乘，相反，这两个符号有着完全不同的意思。<br>在布尔代数中，符号 +意味着两个集合合并，两个集合的合并就是包含第一个集合的所有<br>成员及第二个集合的所有成员。例如， B + W表示黑猫和白猫的集合。<br>布尔代数中的符号×意味着取两个集合的交集，两个集合的交集包含的元素既在第一个<br>集合中，也在第二个集合中 。</p></li><li><p>交换律、结合律和分配律在布尔代数中均适用。而且，在布尔代数中，操作符 +可以对×<br>进行分配，这在传统代数中是不成立的，即：<br>W +（ B× F） =（ W + B）×（ W + F）<br>这个式子表示白猫（ W）和黑色母猫（ B× F）的并集和等式右边两个集合的交集是一样<br>的，这两个集合是白猫和黑猫的并集（ W + B）及白猫和母猫的并集（ W + F） 。要掌握这个规<br>则有些困难，但它的确有用。为了使布尔代数更加完整，我们还需要两个符号。这两个符号看上去像数字，但它们并<br>不真的是数字，因为有时候它们和数字有些不同。符号“ 1”在布尔代数中表示“整个宇宙<br>(全集)”，也就是我们所谈论的每件事物。本例中，符号“ 1”表示“所有的猫”。这样：<br>M + F = 1<br>即母猫和公猫的并集是所有的猫。同样，黄褐色猫、黑猫、白猫及其他颜色的猫的并集<br>也是所有的猫，即：    T + B + W + O = 1  </p><p>我们所需要的另外一个符号是“ 0”。在布尔代数中， “ 0”表示空集，即不含任何事物的<br>集合。当求取两个完全相互排斥的集合的交集时，空集就产生了。例如，既是母的又是公的<br>猫的集合可以表示为：<br>F× M = 0  </p></li><li><p>程序的执行借鉴了逻辑，使用了与（and|&amp;&amp;），或（or| ||），非（！求反），0代表没有 1代表存在。程序通过复杂的逻辑判断最终等到我们想要的结果。优先级 ! &gt; &amp;&amp; &gt; || </p></li></ol><h1 id="五-二进制加减法"><a href="#五-二进制加减法" class="headerlink" title="五.二进制加减法"></a>五.二进制加减法</h1><p>1.加法正是计算机唯一所做的事情  </p><p>2.原来的减法题目是：2 5 3－ 1 7 6<br>    表达式加一个数再减同一个数得到的结果是一样的。所以先加上 1 0 0 0，再减去1 0 0 0：<br>    2 5 3－ 176 + 1000－ 1 0 0 0<br>    这个式子等同于下面的式子：<br>    2 5 3－ 176 + 999 + 1－ 1 0 0 0<br>    再按如下方式重新组合：<br>    2 5 3 +（ 9 9 9 - 1 7 6） + 1－ 1 0 0 0<br>    这与前面描述过的用 9的补数进行的计算是一致的  </p><p>3.</p><p>同样的方法可用于二进制数减法，而且会比十进制数减法来得简单。让我们看看该如何做。<br>原来的减法题目是：<br>    2 5 3<br>－ 1 7 6<br>? ? ?<br>当把这些数转化为二进制数时，问题变成：<br>    １１１１１１０１<br>－１０１１００００<br>？？？？？？？？<br>步骤1 用11111111减去减数：<br>     1 1 1 1 1 1 0 1<br>－ 1 0 1 1 0 0 0 0<br>     0 1 0 0 1 1 1 1<br>当计算十进制数减法时，减数是从一串 9中减去，得到称为 9的补数的结果。对于二进制<br>数减法，减数从一串1中减去，差称为1的补数。但请注意，求1的补数实际上并不需要做减法，<br>因为1的补数中，原来的 0变成1，原来的 1变成0，所以， 1的补数有时也称为相反数 或反码。<br>（你是否还记得第11章中反向器的作用是把 0变成1，把1变成0。 ）<br>步骤2 把步骤1中求得的补数和被减数相加：<br>    1 1 1 1 1 1 0 1<br>+  0 1 0 0 1 1 1 1<br>1 0 1 0 0 1 1 0 0<br>步骤3 对结果加1：<br>1 0 1 0 0 1 1 0 0<br>+ 1<br>1 0 1 0 0 1 1 0 1<br>步骤4 减去1 0 0 0 0 0 0 0 0（ 2 5 6） ：  </p><p>​     1 0 1 0 0 1 1 0 1<br>－ 1 0 0 0 0 0 0 0 0<br>​           1 0 0 1 1 0 1<br>该结果就是十进制数 7 7。  </p><p>现在把两数颠倒位置后再做一遍。在十进制中，减法题目对应于：<br>1 7 6<br>－ 2 5 3<br>? ? ?<br>而在二进制中，即是：<br>    1 0 1 1 0 0 0 0<br>－ 1 1 1 1 1 1 0 1<br>? ? ? ? ? ? ? ?<br>步骤1 从11111111中减去减数。得到补数：<br>     1 1 1 1 1 1 1 1<br>－ 1 1 1 1 1 1 0 1<br>     0 0 0 0 0 0 1 0<br>步骤2 把步骤1中的补数和被减数相加：<br>   1 0 1 1 0 0 0 0<br>+ 0 0 0 0 0 0 1 0<br>   1 0 1 1 0 0 1 0<br>现在， 11111111必须再从结果中减掉。当减数比被减数小时，可以通过先加 1再减去<br>1 0 0 0 0 0 0 0 0来达到此目的。但现在这样做却会用到借位。所以，我们先用 11111111减去步骤2<br>中的结果：<br>1 1 1 1 1 1 1 1<br>－ 1 0 1 1 0 0 1 0<br>0 1 0 0 1 1 0 1<br>这实际上是对步骤2中得到的结果取反。最后的结果是 7 7，而真正的答案应该是－ 7 7。<br>现在，已经可以改进加法机使它既能执行加法操作亦能执行减法操作。为使简便起见，<br>这个加/减法机只执行被减数大于减数的减法操作，即差为正数的操作。  </p><h1 id="六-存储计算"><a href="#六-存储计算" class="headerlink" title="六.存储计算"></a>六.存储计算</h1><ol><li>例如，假设我们希望先把三个数字加在一起，然后把另两个数字加在一起，最后再把另<br>外三个数加在一起。我们可能会将这些数字存储在从地址 0 0 0 0 h开始的R A M阵列中，存储器<br>的内容如下所示：  <img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172514487.png" alt="image-20200910172514487" style="zoom:50%;" /></li></ol><p>这是本书第 1 6章所说明的内容。方格里是存储单元中的内容，存储器的每一个字节在一<br>个方格中。方格的地址在方格左面，并非每一个地址都要表示出来，存储器的地址是连续的，<br>因而可以算出某个方格的地址。方格的右侧是关于这个存储单元的注释，它们表示出我们希<br>望自动加法器在这些空格中存储三个结果。 （虽然这些方格是空的，但存储单元并非空的。存<br>储单元中总有一些东西，即使只是随机数，但此时它不是有用的数。 ）<br>现在可以试一下十六进制算术运算并且把结果存到方格中，但这并不是此项试验的要点，<br>我们想让自动加法器来做一些额外的工作。<br>不是让自动加法器只做一件事情—在最初的加法器中，只是把 R A M地址中的内容加到<br>称为累加器的 8位锁存器中—实际上是让它做四件不同的事。要做加法，需先从存储器中传<br>送一个字节到累加器中，这个操作叫作 L o a d（装载） 。第二项所要执行的操作是把存储器中的<br>一个字节加( A d d )到累加器中。第三项是从累加器中取出结果，保存 ( S t o r e )到存储器中。最后，<br>需要有一些方法使自动加法器停止 ( H a l t )工作。<br>详细说来，让自动加法器所做的工作如下所示：<br>• 把地址0 0 0 0 h中的数装载到累加器中<br>• 把地址0 0 0 1 h中的数加到累加器中<br>• 把地址0 0 0 2 h中的数加到累加器中<br>• 把累加器中的数保存到地址 0 0 0 3 h中<br>• 把地址0 0 0 4 h中的数装载到累加器中  </p><p>• 把地址0 0 0 5 h中的数加到累加器中<br>• 把累加器中的数保存到地址 0 0 0 6 h中<br>• 把地址0 0 0 7 h中的数装载到累加器中<br>• 把地址0 0 0 8 h中的数加到累加器中<br>• 把地址0 0 0 9 h中的数加到累加器中<br>• 把累加器中的数保存到地址 0 0 0 A h中<br>• 停止自动加法器的工作<br>注意，同最初的自动加法器一样，存储器的每个字节的地址是连续的，开始处为 0 0 0 0 h。<br>以前自动加法器只是简单地把存储器中相应地址的数加到累加器中。某些情况下，现在仍然<br>需要这样做，但有时我们也想直接把存储器中的数装载到累加器中或者把累加器中的数保存<br>到存储器中。在所有事情都完成以后，我们还想让自动加法器停下来以便检查 R A M阵列中的<br>内容。<br>怎样完成这些工作呢？只是简单地键入一组数到 R A M中并期望自动加法器来正确操作是<br>不可能的。对于 R A M中的每个数字，我们还需要一个数字代码来表示自动加法器所要做的工<br>作：装载，加，保存或停止。<br>也许最容易（但肯定不是最便宜）的方法是把这些代码存储在一个完全独立的 R A M阵列<br>中。这第二个 RAM 阵列与最初的 R A M阵列同时被访问，但它存放的不是要加的数，而是用<br>来表明自动加法器将要对最初的 R A M阵列的相应地址进行某种操作的代码。这两个 R A M阵列<br>可以分别标为数据（最初的 R A M阵列）和代码（新的 R A M阵列） ：  </p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172641916.png" alt="image-20200910172641916" style="zoom:50%;" /><p>已经确认新的自动加法器能够把“和”写入到最初的 R A M阵列（标为数据） ，而要写入新<br>的R A M阵列（标为代码）则只能通过控制面板来进行。<br>我们用4个代码来表示自动加法器希望能实现的 4个操作。 4个代码可任意指定，下面为可<br>能的一组代码：  </p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172724261.png" alt="image-20200910172724261" style="zoom:50%;" /><p>为了执行以上例子中提到的三组加法，需要用控制面板把下面这些数保存到代码R A M阵列中  :</p><img src="C:\Users\v_ghaoliu\AppData\Roaming\Typora\typora-user-images\image-20200910172803127.png" alt="image-20200910172803127" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-编码&quot;&gt;&lt;a href=&quot;#一-编码&quot; class=&quot;headerlink&quot; title=&quot;一.编码&quot;&gt;&lt;/a&gt;一.编码&lt;/h1&gt;&lt;p&gt;1.人最伟大的进化就是语言和文字，前者方便我们交流，后者使我们的知识得以保留。但不是什么时候语言都是那么的方便，在离得很远的</summary>
      
    
    
    
    <category term="原理:计算机发展史" scheme="http://yoursite.com/categories/%E5%8E%9F%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    
    
    <category term="隐藏在计算机里的原理" scheme="http://yoursite.com/tags/%E9%9A%90%E8%97%8F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8C%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第一篇</title>
    <link href="http://yoursite.com/2020/08/11/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://yoursite.com/2020/08/11/%E7%AC%AC%E4%B8%80%E7%AF%87/</id>
    <published>2020-08-11T08:18:56.000Z</published>
    <updated>2020-08-13T07:46:28.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-学习计划"><a href="#一-学习计划" class="headerlink" title="一.学习计划"></a>一.学习计划</h1><p>1.数据结构与算法<br>2.计算机基础</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-学习计划&quot;&gt;&lt;a href=&quot;#一-学习计划&quot; class=&quot;headerlink&quot; title=&quot;一.学习计划&quot;&gt;&lt;/a&gt;一.学习计划&lt;/h1&gt;&lt;p&gt;1.数据结构与算法&lt;br&gt;2.计算机基础&lt;/p&gt;
</summary>
      
    
    
    
    <category term="开始" scheme="http://yoursite.com/categories/%E5%BC%80%E5%A7%8B/"/>
    
    
    <category term="计划" scheme="http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
</feed>
